# 架构分析

---

### 项目结构

TeamTalk开源项目的Windows客户端架构可以简要描述如下：

1. 用户界面层（UI Layer）：
   - Windows客户端采用图形用户界面（GUI）来与用户交互，提供了各种界面元素和交互功能，包括聊天窗口、联系人列表、群组列表、设置界面等。
   - 用户界面层负责接收用户的输入操作，显示界面元素，并将用户的操作转发给业务逻辑层进行处理。
2. 业务逻辑层（Business Logic Layer）：
   - 业务逻辑层负责处理用户的操作和事件，包括用户登录、消息发送、联系人管理、群组管理等业务逻辑。
   - 它与服务器端进行通信，发送请求并接收响应，实现与服务器的数据交互。
   - 业务逻辑层还负责处理用户状态的管理，包括在线状态、离线状态、忙碌状态等。
3. 网络通信层（Network Communication Layer）：
   - 网络通信层负责与服务器进行网络通信，发送和接收数据。
   - 它使用TCP/IP协议栈进行数据传输，并与服务器端的网络通信模块进行交互。
   - 网络通信层处理与服务器的连接建立、断开、数据传输等相关操作。
4. 数据持久化层（Data Persistence Layer）：
   - 数据持久化层负责将客户端的数据进行持久化存储，包括用户的个人信息、聊天记录、联系人列表等。
   - 它使用数据库或文件系统等方式来进行数据的读写操作，以保证数据的安全性和可靠性。
5. 辅助模块（Auxiliary Modules）：
   - Windows客户端可能包含一些辅助模块，如音视频模块、文件传输模块等。
   - 音视频模块负责处理音视频通话的建立和管理，包括音频采集、编解码、网络传输等。
   - 文件传输模块负责处理文件的上传、下载和共享，实现文件的传输功能。

总体而言，TeamTalk Windows客户端的架构采用了分层的设计，将不同的功能模块分解为不同的层级，实现了界面、业务逻辑、网络通信和数据持久化的分离。这样的架构设计使得代码的组织更加清晰，模块之间的耦合度较低，便于维护和扩展。具体的实现可能会根据项目的版本和需求有所差异，需要深入研究源代码以获取更详细的架构信息。

1. 3rdParty：第三方开源工具
   - include：头文件 google、sqlite3
   - src：源文件 cxImage、http、json、libogg、libsecurity、libspeex、protobuff、yaolog
2. commonlib：各个项目共享的静态库\导出库文件
3. solution：工程文件
4. inlude：头文件
5. core：源文件，包括duilib、network、utility
6. src：源文件，包括duilibex、gifsmiley、modules、teamtalk
7. package：项目打包目录
   - data：软件数据
   - gui：界面布局控件控制
   - users：用户数据
   - teamtalk：软件主体
     - ttlogconfig.ini：日志设置
     - speexdec.exe：语音处理
     - teamtalk.exe：应用主体
     - Duilib.dll
     - GifSmiley.dll
     - httpclient.dll
     - libogg.dll
     - Modules.dll
     - network.dll
     - sqliet3.dll
     - utility.dll

### 解决方案结构

打开方式：直接使用vs打开solution目录下的teamtalk.sln编译即可，

teamtalk包含以下10个项目：

1. teamtalk：是主程序入口工程；
2. Duilib：开源界面库，该界面库模仿web开发中的布局技术，使用xml文件来布局windows界面，并且在主窗口上绘制所有子控件，即所谓的directUI技术
3. httpclient：程序中集成的http请求库，
   - 登录前程序会先连接服务器的login_server以获得后续需要登录的msg_server的ip地址和端口号等信息，这里使用的是http协议，
   - 同时聊天过程中收发的聊天图片与图片服务器msfs也使用http协议来收发这些图片；
4. Modules：项目中的各个主要的业务模块
5. network：网络通信的代码，客户端和服务器使用的是同套网络通信库，只不过如果服务器运行在linux下，其核心的IO复用模型是epoll，而客户端使用的IO复用模型是select；
6. utility：包含了工具类工程，比如sqlite的包装接口、md5工具类等。
7. GifSmiley：是程序中用来解析和显示Gif格式的图片的库，以支持Gif图片的动画效果；
8. libogg：语音库用来解析声音文件，pc客户端会收到来自移动端的语音消息，相比较传统的 `.wav、.mp3、.wma`，`.ogg` 格式的不仅音质高，而且音频文件的体积小，腾讯的QQ游戏英雄杀中的语音也是使用这个格式的。
9. speexdec：和ogg格式相关的编码和解码器；
10. libspeex：音频压缩库

除了上面这些库以外，项目中还使用到了sqlite库、谷歌protobuf库、C++跨平台日志库yaolog等（可以单独打印出网络通信中的字节流的二进制形式）。

关于yaolog可参考：http://blog.csdn.net/gemo/article/details/8499692

### 整体架构

客户端框架基于网络库，从底层网络库往上进行分析大致框架描述一下，

客户端总体有两个任务队列（逻辑任务队列，http任务队列）、四个线程每个队列有一个对应的线程，

- 逻辑任务队列：处理业务逻辑任务
- http任务队列：处理http有关的业务，其中有一个线程池，默认线程池线程个数为1
- 网络IO线程：负责处理IO数据的读写操作，
- 主线程：
  - 负责界面消息循环，用来与用户交互：
  - 主线程中有个代理窗口，这个代理窗口利用win32的消息队列，使用窗口处理函数来统一接口，负责处理客户端后台业务与界面的数据传递

1. 客户端网络库通过提前注册的会话反应函数，来进行数据的回调，并根据serviceID来调用相应模块中的与cmdID对应的业务函数。
2. 客户端各个模块如登录模块、会话模块、文件传输模块等，都抽象成一个个模块，数据包过来的时候会选择对应的模块进行相应的逻辑处理。
3. 基础模块和界面模块之间的数据流，则通过观察者模式来进行通知相应界面的视图改变。

### 分析总结

至此，整个客户端程序结构就介绍完了，我们总结一下，实际上程序有如下几类线程：

1. 网络事件检测线程，用于接收和发送网络数据；
2. http任务处理线程用于处理http操作；
3. 普通的任务处理线程，用于处理一般性的任务，比如登录；
4. UI线程，界面逻辑处理，同时在UI线程里面有一个代理窗口的窗口过程函数，用于非UI线程与UI线程之间的数据流和逻辑中转，核心是利用PostMessage往代理线程投递事件，事件消息参数携带任务信息。

### 部分问题

#### （1）连接函数时长设定

socket函数connect()连接等待时长设定

传统的做法是将socket设置为非阻塞的，调用完connect函数之后，调用select函数检测socket是否可写，在select函数里面设置超时时间。代码如下：

```cpp
// 为了调试方便，暂且注释掉
int ret = ::connect(m_hSocket, (struct sockaddr*)&addrSrv, sizeof(addrSrv));
if (ret == 0)
{
	m_bConnected = TRUE;
	return TRUE;
}
 
if (ret == SOCKET_ERROR && WSAGetLastError() != WSAEWOULDBLOCK)
{
	return FALSE;
}
 
fd_set writeset;
FD_ZERO(&writeset);
FD_SET(m_hSocket, &writeset);
struct timeval tv = { timeout, 0 };
if (::select(m_hSocket + 1, NULL, &writeset, NULL, &tv) != 1)
{
	return FALSE;
}
return TRUE;
```

我们看看teamtalk里面怎么做的：

![image-20230530170942119](assets/image-20230530170942119.png)



#### （2）发送表情与图片的不同

发送表情Emoticon和发送图片的不同：

- 发送表情（Emoticon）：
    - 表情是一种<font color='#BAOC2F'>简化的图形符号</font>，通常用于表示情感或表达特定含义。
    - TeamTalk 客户端通常会提供一个表情包（Emoticon Pack），其中包含了一系列的表情图标。
    - 用户可以从表情包中选择一个表情，然后发送给其他用户或在聊天中使用。
    - 表情一般以特定的文本符号或关键字表示，例如 ":)" 表示笑脸表情。
- 发送图片：
    - 图片可以是任意的图像文件，通常以常见的图像格式（如 JPEG、PNG、GIF）保存。
    - 用户可以选择一个图片文件，然后发送给其他用户或在聊天中使用。
    - 图片可以是任何内容，例如照片、插图、动态图等。
    - TeamTalk 客户端通常会支持在聊天中直接插入或发送图片文件。
- 总结：
    - 发送表情和发送图片的区别在于表情是一种预定义的简化图形符号，而图片可以是任意的图像文件。
    - 表情通常以文本符号表示，而图片是以实际的图像文件形式发送和显示。
    - 根据 TeamTalk 客户端的不同，发送表情和发送图片可能会有不同的操作方式和界面设计。

服务器端对发送表情Emoticon和发送图片的不同处理方式：

1. 图片处理：
    - 服务器端接收到客户端发送的图片后，可能会对图片进行验证和处理，以确保图片的合法性和安全性。
    - 服务器端可能会检查图片的格式、大小、文件类型等，并可能对图片进行压缩或调整尺寸以节省带宽和存储空间。
    - 服务器端可能会将接收到的图片保存到指定的位置，并为其分配一个唯一的标识符或路径，以便在需要时能够正确地获取和发送给其他客户端。
2. 表情处理：
    - 服务器端对客户端发送的表情通常会先<font color='#BAOC2F'>解析表情的文本符号或关键字</font>，<font color='#BAOC2F'>然后将其转换为对应的表情图标或动画</font>。
    - 服务器端可能会维护一个表情包的集合，其中包含了预定义的表情图标或动画，并与对应的文本符号或关键字进行映射。
    - 当服务器端接收到<font color='#BAOC2F'>包含表情文本的消息时</font>，它会<font color='#BAOC2F'>解析该文本并将其转换为对应的表情图标</font>，然后将转换后的消息发送给目标客户端。





